package m_util

import (
	"errors"
	"fmt"
	"xorm.io/xorm"
	"io"
	"os"
	"reflect"
	"strconv"
	"strings"
	"time"
	"xorm.io/core"
)

//导出表数据
const (
	//表结构
	DUMP_STRUCTURE int = 0x00001
	//表索引
	DUMP_INDEX int = 0x00002
	//表数据
	DUMP_DATA int = 0x00040
)

//导出表数据
func Dump(dao *xorm.Engine, tables []*core.Table, fg int, w io.Writer) error {
	var dialect core.Dialect
	var distDBName string
	dialect = dao.Dialect()
	distDBName = string(dao.Dialect().DBType())
	_, err := io.WriteString(w, fmt.Sprintf("/*Generated by xorm v%s %s, from %s to %s*/\n\n",
		xorm.Version, time.Now().In(dao.TZLocation).Format("2006-01-02 15:04:05"), dao.Dialect().DBType(), strings.ToUpper(distDBName)))
	if err != nil {
		return err
	}

	for i, table := range tables {
		if i > 0 {
			_, err = io.WriteString(w, "\n")
			if err != nil {
				return err
			}
		}

		if fg&DUMP_STRUCTURE == DUMP_STRUCTURE {
			_, err = io.WriteString(w, dialect.CreateTableSql(table, "", table.StoreEngine, "")+";\n")
			if err != nil {
				return err
			}
		}

		if fg&DUMP_INDEX == DUMP_INDEX {
			for _, index := range table.Indexes {
				_, err = io.WriteString(w, dialect.CreateIndexSql(table.Name, index)+";\n")
				if err != nil {
					return err
				}
			}
		}

		if fg&DUMP_DATA == DUMP_DATA {

			cols := table.ColumnsSeq()
			colNames := dialect.Quote(strings.Join(cols, dialect.Quote(", ")))

			rows, err := dao.DB().Query("SELECT " + colNames + " FROM " + dao.Quote(table.Name))
			if err != nil {
				return err
			}
			defer func() {
				if err := rows.Close(); err != nil {
					panic(err)
				}
			}()

			for rows.Next() {
				dest := make([]interface{}, len(cols))
				err = rows.ScanSlice(&dest)
				if err != nil {
					return err
				}

				_, err = io.WriteString(w, "INSERT INTO "+dialect.Quote(table.Name)+" ("+colNames+") VALUES (")
				if err != nil {
					return err
				}

				var temp string
				for i, d := range dest {
					col := table.GetColumn(cols[i])
					if col == nil {
						return errors.New("unknow column error")
					}

					if d == nil {
						temp += ", NULL"
					} else if col.SQLType.IsText() || col.SQLType.IsTime() {
						var v = fmt.Sprintf("%s", d)
						if strings.HasSuffix(v, " +0000 UTC") {
							temp += fmt.Sprintf(", '%s'", v[0:len(v)-len(" +0000 UTC")])
						} else {
							temp += ", '" + strings.Replace(v, "'", "''", -1) + "'"
						}
					} else if col.SQLType.IsBlob() {
						if reflect.TypeOf(d).Kind() == reflect.Slice {
							temp += fmt.Sprintf(", %s", dialect.FormatBytes(d.([]byte)))
						} else if reflect.TypeOf(d).Kind() == reflect.String {
							temp += fmt.Sprintf(", '%s'", d.(string))
						}
					} else if col.SQLType.IsNumeric() {
						switch reflect.TypeOf(d).Kind() {
						case reflect.Slice:
							temp += fmt.Sprintf(", %s", string(d.([]byte)))
						case reflect.Int16, reflect.Int8, reflect.Int32, reflect.Int64, reflect.Int:
							if col.SQLType.Name == core.Bool {
								temp += fmt.Sprintf(", %v", strconv.FormatBool(reflect.ValueOf(d).Int() > 0))
							} else {
								temp += fmt.Sprintf(", %v", d)
							}
						case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
							if col.SQLType.Name == core.Bool {
								temp += fmt.Sprintf(", %v", strconv.FormatBool(reflect.ValueOf(d).Uint() > 0))
							} else {
								temp += fmt.Sprintf(", %v", d)
							}
						default:
							temp += fmt.Sprintf(", %v", d)
						}
					} else {
						s := fmt.Sprintf("%v", d)
						if strings.Contains(s, ":") || strings.Contains(s, "-") {
							if strings.HasSuffix(s, " +0000 UTC") {
								temp += fmt.Sprintf(", '%s'", s[0:len(s)-len(" +0000 UTC")])
							} else {
								temp += fmt.Sprintf(", '%s'", s)
							}
						} else {
							temp += fmt.Sprintf(", %s", s)
						}
					}
				}
				_, err = io.WriteString(w, temp[2:]+");\n")
				if err != nil {
					return err
				}
			}
		}
		// FIXME: Hack for postgres
		if string(dialect.DBType()) == core.POSTGRES && table.AutoIncrColumn() != nil {
			_, err = io.WriteString(w, "SELECT setval('table_id_seq', COALESCE((SELECT MAX("+table.AutoIncrColumn().Name+") FROM "+dialect.Quote(table.Name)+"), 1), false);\n")
			if err != nil {
				return err
			}
		}
	}
	return nil
}

//导出表数据到文件
func DumpToFile(dao *xorm.Engine, tables []*core.Table, fg int, fp string) error {
	f, err := os.Create(fp)
	if err != nil {
		return err
	}
	defer func() {
		_ = f.Close()
	}()
	return Dump(dao, tables, fg, f)
}