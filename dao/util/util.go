package util

import (
	"bufio"
	"bytes"
	"database/sql"
	"errors"
	"fmt"
	"github.com/go-xorm/xorm"
	"io"
	"os"
	"reflect"
	"strconv"
	"strings"
	"time"
	"xorm.io/core"
)

//导出表数据
const (
	//表结构
	DUMP_STRUCTURE int = 0x00001
	//表索引
	DUMP_INDEX int = 0x00002
	//表数据
	DUMP_DATA int = 0x00040
)

//导出表数据
func Dump(dao *xorm.Engine, tables []*core.Table, fg int, w io.Writer) error {
	var dialect core.Dialect
	var distDBName string
	dialect = dao.Dialect()
	distDBName = string(dao.Dialect().DBType())
	_, err := io.WriteString(w, fmt.Sprintf("/*Generated by xorm v%s %s, from %s to %s*/\n\n",
		xorm.Version, time.Now().In(dao.TZLocation).Format("2006-01-02 15:04:05"), dao.Dialect().DBType(), strings.ToUpper(distDBName)))
	if err != nil {
		return err
	}

	for i, table := range tables {
		if i > 0 {
			_, err = io.WriteString(w, "\n")
			if err != nil {
				return err
			}
		}

		if fg&DUMP_STRUCTURE != 0 {
			_, err = io.WriteString(w, dialect.CreateTableSql(table, "", table.StoreEngine, "")+";\n")
			if err != nil {
				return err
			}
		}

		if fg&DUMP_INDEX != 0 {
			for _, index := range table.Indexes {
				_, err = io.WriteString(w, dialect.CreateIndexSql(table.Name, index)+";\n")
				if err != nil {
					return err
				}
			}
		}

		if fg&DUMP_DATA != 0 {

			cols := table.ColumnsSeq()
			colNames := dialect.Quote(strings.Join(cols, dialect.Quote(", ")))

			rows, err := dao.DB().Query("SELECT " + colNames + " FROM " + dao.Quote(table.Name))
			if err != nil {
				return err
			}
			defer func() {
				if err := rows.Close(); err != nil {
					panic(err)
				}
			}()

			for rows.Next() {
				dest := make([]interface{}, len(cols))
				err = rows.ScanSlice(&dest)
				if err != nil {
					return err
				}

				_, err = io.WriteString(w, "INSERT INTO "+dialect.Quote(table.Name)+" ("+colNames+") VALUES (")
				if err != nil {
					return err
				}

				var temp string
				for i, d := range dest {
					col := table.GetColumn(cols[i])
					if col == nil {
						return errors.New("unknow column error")
					}

					if d == nil {
						temp += ", NULL"
					} else if col.SQLType.IsText() || col.SQLType.IsTime() {
						var v = fmt.Sprintf("%s", d)
						if strings.HasSuffix(v, " +0000 UTC") {
							temp += fmt.Sprintf(", '%s'", v[0:len(v)-len(" +0000 UTC")])
						} else {
							temp += ", '" + strings.Replace(v, "'", "''", -1) + "'"
						}
					} else if col.SQLType.IsBlob() {
						if reflect.TypeOf(d).Kind() == reflect.Slice {
							temp += fmt.Sprintf(", %s", dialect.FormatBytes(d.([]byte)))
						} else if reflect.TypeOf(d).Kind() == reflect.String {
							temp += fmt.Sprintf(", '%s'", d.(string))
						}
					} else if col.SQLType.IsNumeric() {
						switch reflect.TypeOf(d).Kind() {
						case reflect.Slice:
							temp += fmt.Sprintf(", %s", string(d.([]byte)))
						case reflect.Int16, reflect.Int8, reflect.Int32, reflect.Int64, reflect.Int:
							if col.SQLType.Name == core.Bool {
								temp += fmt.Sprintf(", %v", strconv.FormatBool(reflect.ValueOf(d).Int() > 0))
							} else {
								temp += fmt.Sprintf(", %v", d)
							}
						case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
							if col.SQLType.Name == core.Bool {
								temp += fmt.Sprintf(", %v", strconv.FormatBool(reflect.ValueOf(d).Uint() > 0))
							} else {
								temp += fmt.Sprintf(", %v", d)
							}
						default:
							temp += fmt.Sprintf(", %v", d)
						}
					} else {
						s := fmt.Sprintf("%v", d)
						if strings.Contains(s, ":") || strings.Contains(s, "-") {
							if strings.HasSuffix(s, " +0000 UTC") {
								temp += fmt.Sprintf(", '%s'", s[0:len(s)-len(" +0000 UTC")])
							} else {
								temp += fmt.Sprintf(", '%s'", s)
							}
						} else {
							temp += fmt.Sprintf(", %s", s)
						}
					}
				}
				_, err = io.WriteString(w, temp[2:]+");\n")
				if err != nil {
					return err
				}
			}
		}
		// FIXME: Hack for postgres
		if string(dialect.DBType()) == core.POSTGRES && table.AutoIncrColumn() != nil {
			_, err = io.WriteString(w, "SELECT setval('table_id_seq', COALESCE((SELECT MAX("+table.AutoIncrColumn().Name+") FROM "+dialect.Quote(table.Name)+"), 1), false);\n")
			if err != nil {
				return err
			}
		}
	}
	return nil
}

//导出表数据到文件
func DumpToFile(dao *xorm.Engine, tables []*core.Table, fg int, fp string) error {
	f, err := os.Create(fp)
	if err != nil {
		return err
	}
	defer func() {
		_ = f.Close()
	}()
	return Dump(dao, tables, fg, f)
}

//导入数据
//有此方法是因为 DB.Import() 有 bug
//@link https://github.com/go-xorm/xorm/issues/1231#issue-410613530
func Import(dao *xorm.Engine, r io.Reader) ([]sql.Result, error) {
	var results []sql.Result
	var lastError error
	scanner := bufio.NewScanner(r)

	semiColSplit := func(data []byte, atEOF bool) (advance int, token []byte, err error) {
		if atEOF && len(data) == 0 {
			return 0, nil, nil
		}
		if i := bytes.Index(data, []byte(";\n")); i >= 0 {
			return i + 2, data[0:i], nil
		}
		// If we're at EOF, we have a final, non-terminated line. Return it.
		if atEOF {
			return len(data), data, nil
		}
		// Request more data.
		return 0, nil, nil
	}

	scanner.Split(semiColSplit)

	for scanner.Scan() {
		query := strings.Trim(scanner.Text(), " \t\n\r")
		if len(query) > 0 {
			result, err := dao.DB().Exec(query)
			results = append(results, result)
			if err != nil {
				return nil, err
			}
		}
	}

	return results, lastError
}

//从文件导入数据
func ImportFromFile(dao *xorm.Engine, fpath string) ([]sql.Result, error) {
	file, err := os.Open(fpath)
	if err != nil {
		return nil, err
	}

	defer func() {
		_ = file.Close()
	}()
	return Import(dao, file)
}

//获取表信息
func GetTableInfo(dao *xorm.Engine, tableName string) (*core.Table, error) {
	tables, err := dao.Dialect().GetTables()
	if err != nil {
		return nil, err
	}
	var table *core.Table
	for _, v := range tables {
		if strings.EqualFold(v.Name, tableName) {
			table = v
		}
	}
	if table == nil {
		return nil, fmt.Errorf("Unknown table: %s", tableName)
	}
	colSeq, cols, err := dao.Dialect().GetColumns(table.Name)
	if err != nil {
		return nil, err
	}
	for _, name := range colSeq {
		table.AddColumn(cols[name])
	}
	indexes, err := dao.Dialect().GetIndexes(table.Name)
	if err != nil {
		return nil, err
	}
	table.Indexes = indexes
	for _, index := range indexes {
		for _, name := range index.Cols {
			if col := table.GetColumn(name); col != nil {
				col.Indexes[index.Name] = index.Type
			} else {
				return nil, fmt.Errorf("Unknown col %s in index %v of table %v, columns %v", name, index.Name, table.Name, table.ColumnsSeq())
			}
		}
	}
	return table, nil
}
