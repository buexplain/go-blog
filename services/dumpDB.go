package s_services

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	"reflect"
	"strconv"
	"strings"
	"time"
	"xorm.io/xorm"
	"xorm.io/xorm/dialects"
	"xorm.io/xorm/schemas"
)

//导出表数据
const (
	//表结构
	DUMP_DB_STRUCTURE int = 0x00001
	//表索引
	DUMP_DB_INDEX int = 0x00002
	//表数据
	DUMP_DB_DATA int = 0x00040
)

// dumpTables dump database all table structs and data to w with specify db type
//@link https://gitea.com/xorm/xorm/issues/1231
//@link https://gitea.com/xorm/xorm/issues/1612
func DumpDB(engine *xorm.Engine, tables []*schemas.Table, w io.Writer, fg int, tp ...schemas.DBType) error {
	var dstDialect dialects.Dialect
	if len(tp) == 0 {
		dstDialect = engine.Dialect()
	} else {
		dstDialect = dialects.QueryDialect(tp[0])
		if dstDialect == nil {
			return errors.New("Unsupported database type")
		}

		uri := engine.Dialect().URI()
		destURI := *uri
		if err := dstDialect.Init(&destURI); err != nil {
			return err
		}
	}

	_, err := io.WriteString(w, fmt.Sprintf("/*Generated by xorm %s, from %s to %s*/\n\n",
		time.Now().In(engine.TZLocation).Format("2006-01-02 15:04:05"), engine.Dialect().URI().DBType, dstDialect.URI().DBType))
	if err != nil {
		return err
	}

	for i, table := range tables {
		tableName := table.Name
		if dstDialect.URI().Schema != "" {
			tableName = fmt.Sprintf("%s.%s", dstDialect.URI().Schema, table.Name)
		}
		originalTableName := table.Name
		if engine.Dialect().URI().Schema != "" {
			originalTableName = fmt.Sprintf("%s.%s", engine.Dialect().URI().Schema, table.Name)
		}
		if i > 0 {
			_, err = io.WriteString(w, "\n")
			if err != nil {
				return err
			}
		}

		//导出表结构
		if fg&DUMP_DB_STRUCTURE == DUMP_DB_STRUCTURE {
			sqls, _ := dstDialect.CreateTableSQL(table, tableName)
			for _, s := range sqls {
				_, err = io.WriteString(w, s+";\n")
				if err != nil {
					return err
				}
			}
			if len(table.PKColumns()) > 0 && dstDialect.URI().DBType == schemas.MSSQL {
				_, _ = fmt.Fprintf(w, "SET IDENTITY_INSERT [%s] ON;\n", table.Name)
			}
		}

		//导出表索引
		if fg&DUMP_DB_INDEX == DUMP_DB_INDEX {
			for _, index := range table.Indexes {
				_, err = io.WriteString(w, dstDialect.CreateIndexSQL(table.Name, index)+";\n")
				if err != nil {
					return err
				}
			}
		}

		//导出表数据
		if fg&DUMP_DB_DATA == DUMP_DB_DATA {
			cols := table.ColumnsSeq()
			colNames := engine.Dialect().Quoter().Join(cols, ", ")
			destColNames := dstDialect.Quoter().Join(cols, ", ")

			rows, err := engine.DB().QueryContext(context.Background(), "SELECT "+colNames+" FROM "+engine.Quote(originalTableName))
			if err != nil {
				return err
			}
			defer func() {
				_ = rows.Close()
			}()

			for rows.Next() {
				dest := make([]interface{}, len(cols))
				err = rows.ScanSlice(&dest)
				if err != nil {
					return err
				}

				_, err = io.WriteString(w, "INSERT INTO "+dstDialect.Quoter().Quote(tableName)+" ("+destColNames+") VALUES (")
				if err != nil {
					return err
				}

				var temp string
				for i, d := range dest {
					col := table.GetColumn(cols[i])

					if col == nil {
						return errors.New("unknow column error")
					}

					if d == nil {
						temp += ", NULL"
					} else if col.SQLType.IsText() || col.SQLType.IsTime() {
						var v string
						if col.SQLType.IsTime() {
							//engine.DatabaseTZ设置为UTC时区，所以入库的都是UTC时间
							//sqlite3设置为本地时区，所以出库口时间都由UTC时间转为本地时区
							//所以时区应该再次格式化为UTC时间，这样导入的时候依然是UTC时间
							if t, ok := d.(time.Time); ok {
								v = t.UTC().Format("2006-01-02 15:04:05")
								temp += fmt.Sprintf(", '%s'", v)
							} else {
								return fmt.Errorf("column %s type %+T convert to time.Time error", col.Name, d)
							}
						} else {
							v = fmt.Sprintf("%s", d)
							temp += ", '" + strings.Replace(v, "'", "''", -1) + "'"
						}
						//if strings.HasSuffix(v, " +0000 UTC") {
						//	temp += fmt.Sprintf(", '%s'", v[0:len(v)-len(" +0000 UTC")])
						//} else {
						//	temp += ", '" + strings.Replace(v, "'", "''", -1) + "'"
						//}
					} else if col.SQLType.IsBlob() {
						if reflect.TypeOf(d).Kind() == reflect.Slice {
							temp += fmt.Sprintf(", %s", dstDialect.FormatBytes(d.([]byte)))
						} else if reflect.TypeOf(d).Kind() == reflect.String {
							temp += fmt.Sprintf(", '%s'", d.(string))
						}
					} else if col.SQLType.IsNumeric() {
						switch reflect.TypeOf(d).Kind() {
						case reflect.Slice:
							if col.SQLType.Name == schemas.Bool {
								temp += fmt.Sprintf(", %v", strconv.FormatBool(d.([]byte)[0] != byte('0')))
							} else {
								temp += fmt.Sprintf(", %s", string(d.([]byte)))
							}
						case reflect.Int16, reflect.Int8, reflect.Int32, reflect.Int64, reflect.Int:
							if col.SQLType.Name == schemas.Bool {
								temp += fmt.Sprintf(", %v", strconv.FormatBool(reflect.ValueOf(d).Int() > 0))
							} else {
								temp += fmt.Sprintf(", %v", d)
							}
						case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
							if col.SQLType.Name == schemas.Bool {
								temp += fmt.Sprintf(", %v", strconv.FormatBool(reflect.ValueOf(d).Uint() > 0))
							} else {
								temp += fmt.Sprintf(", %v", d)
							}
						default:
							temp += fmt.Sprintf(", %v", d)
						}
					} else {
						s := fmt.Sprintf("%v", d)
						if strings.Contains(s, ":") || strings.Contains(s, "-") {
							if strings.HasSuffix(s, " +0000 UTC") {
								temp += fmt.Sprintf(", '%s'", s[0:len(s)-len(" +0000 UTC")])
							} else {
								temp += fmt.Sprintf(", '%s'", s)
							}
						} else {
							temp += fmt.Sprintf(", %s", s)
						}
					}
				}

				//将insert语句的value部分转成base4编码
				encodeString := base64.StdEncoding.EncodeToString([]byte(temp[2:]))
				_, err = io.WriteString(w, encodeString+");\n")
				//_, err = io.WriteString(w, temp[2:]+");\n")
				if err != nil {
					return err
				}
			}

			// FIXME: Hack for postgres
			if dstDialect.URI().DBType == schemas.POSTGRES && table.AutoIncrColumn() != nil {
				_, err = io.WriteString(w, "SELECT setval('"+tableName+"_id_seq', COALESCE((SELECT MAX("+table.AutoIncrColumn().Name+") + 1 FROM "+dstDialect.Quoter().Quote(tableName)+"), 1), false);\n")
				if err != nil {
					return err
				}
			}
		}
	}
	return nil

}
