package s_services

import (
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	"reflect"
	"strconv"
	"strings"
	"time"
	"xorm.io/core"
	"xorm.io/xorm"
)

//导出表数据
const (
	//表结构
	DUMP_DB_STRUCTURE int = 0x00001
	//表索引
	DUMP_DB_INDEX int = 0x00002
	//表数据
	DUMP_DB_DATA int = 0x00040
)

// dumpTables dump database all table structs and data to w with specify db type
//@link https://gitea.com/xorm/xorm/issues/1231
func DumpDB(dao *xorm.Engine, tables []*core.Table, w io.Writer, fg int, tp ...core.DbType) error {
	var dialect core.Dialect
	var distDBName string
	if len(tp) == 0 {
		dialect = dao.Dialect()
		distDBName = string(dao.Dialect().DBType())
	} else {
		dialect = core.QueryDialect(tp[0])
		if dialect == nil {
			return errors.New("Unsupported database type")
		}
		_ = dialect.Init(nil, dao.Dialect().URI(), "", "")
		distDBName = string(tp[0])
	}

	_, err := io.WriteString(w, fmt.Sprintf("/*Generated by xorm v%s %s, from %s to %s*/\n\n",
		xorm.Version, time.Now().In(dao.TZLocation).Format("2006-01-02 15:04:05"), dao.Dialect().DBType(), strings.ToUpper(distDBName)))
	if err != nil {
		return err
	}

	for i, table := range tables {
		if i > 0 {
			_, err = io.WriteString(w, "\n")
			if err != nil {
				return err
			}
		}

		//导出表结构
		if fg&DUMP_DB_STRUCTURE == DUMP_DB_STRUCTURE {
			_, err = io.WriteString(w, dialect.CreateTableSql(table, "", table.StoreEngine, "")+";\n")
			if err != nil {
				return err
			}
		}

		//导出表索引
		if fg&DUMP_DB_INDEX == DUMP_DB_INDEX {
			for _, index := range table.Indexes {
				_, err = io.WriteString(w, dialect.CreateIndexSql(table.Name, index)+";\n")
				if err != nil {
					return err
				}
			}
		}

		//导出表数据
		if fg&DUMP_DB_DATA == DUMP_DB_DATA {
			cols := table.ColumnsSeq()
			colNames := dao.Dialect().Quote(strings.Join(cols, dao.Dialect().Quote(", ")))
			destColNames := dialect.Quote(strings.Join(cols, dialect.Quote(", ")))

			rows, err := dao.DB().Query("SELECT " + colNames + " FROM " + dao.Quote(table.Name))
			if err != nil {
				return err
			}
			defer func() {
				_ = rows.Close()
			}()

			for rows.Next() {
				dest := make([]interface{}, len(cols))
				err = rows.ScanSlice(&dest)
				if err != nil {
					return err
				}

				_, err = io.WriteString(w, "INSERT INTO "+dialect.Quote(table.Name)+" ("+destColNames+") VALUES (")
				if err != nil {
					return err
				}

				var temp string
				for i, d := range dest {
					col := table.GetColumn(cols[i])
					if col == nil {
						return errors.New("unknow column error")
					}

					if d == nil {
						temp += ", NULL"
					} else if col.SQLType.IsText() || col.SQLType.IsTime() {
						var v = fmt.Sprintf("%s", d)
						if strings.HasSuffix(v, " +0000 UTC") {
							temp += fmt.Sprintf(", '%s'", v[0:len(v)-len(" +0000 UTC")])
						} else {
							temp += ", '" + strings.Replace(v, "'", "''", -1) + "'"
						}
					} else if col.SQLType.IsBlob() {
						if reflect.TypeOf(d).Kind() == reflect.Slice {
							temp += fmt.Sprintf(", %s", dialect.FormatBytes(d.([]byte)))
						} else if reflect.TypeOf(d).Kind() == reflect.String {
							temp += fmt.Sprintf(", '%s'", d.(string))
						}
					} else if col.SQLType.IsNumeric() {
						switch reflect.TypeOf(d).Kind() {
						case reflect.Slice:
							if col.SQLType.Name == core.Bool {
								temp += fmt.Sprintf(", %v", strconv.FormatBool(d.([]byte)[0] != byte('0')))
							} else {
								temp += fmt.Sprintf(", %s", string(d.([]byte)))
							}
						case reflect.Int16, reflect.Int8, reflect.Int32, reflect.Int64, reflect.Int:
							if col.SQLType.Name == core.Bool {
								temp += fmt.Sprintf(", %v", strconv.FormatBool(reflect.ValueOf(d).Int() > 0))
							} else {
								temp += fmt.Sprintf(", %v", d)
							}
						case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
							if col.SQLType.Name == core.Bool {
								temp += fmt.Sprintf(", %v", strconv.FormatBool(reflect.ValueOf(d).Uint() > 0))
							} else {
								temp += fmt.Sprintf(", %v", d)
							}
						default:
							temp += fmt.Sprintf(", %v", d)
						}
					} else {
						s := fmt.Sprintf("%v", d)
						if strings.Contains(s, ":") || strings.Contains(s, "-") {
							if strings.HasSuffix(s, " +0000 UTC") {
								temp += fmt.Sprintf(", '%s'", s[0:len(s)-len(" +0000 UTC")])
							} else {
								temp += fmt.Sprintf(", '%s'", s)
							}
						} else {
							temp += fmt.Sprintf(", %s", s)
						}
					}
				}
				//将insert语句的value部分转成base4编码
				encodeString := base64.StdEncoding.EncodeToString([]byte(temp[2:]))
				_, err = io.WriteString(w, encodeString+");\n")
				if err != nil {
					return err
				}
			}
		}
		// FIXME: Hack for postgres
		if string(dialect.DBType()) == core.POSTGRES && table.AutoIncrColumn() != nil {
			_, err = io.WriteString(w, "SELECT setval('"+table.Name+"_id_seq', COALESCE((SELECT MAX("+table.AutoIncrColumn().Name+") + 1 FROM "+dialect.Quote(table.Name)+"), 1), false);\n")
			if err != nil {
				return err
			}
		}
	}
	return nil
}
